#ifndef SIXTRACKLIB_COMMON_INTERNAL_MATH_FACTORIAL_H__
#define SIXTRACKLIB_COMMON_INTERNAL_MATH_FACTORIAL_H__

#if !defined( SIXTRL_NO_SYSTEM_INCLUDES )
    #include <stddef.h>
    #include <stdint.h>
    #include <stdlib.h>
#endif /* !defined( SIXTRL_NO_SYSTEM_INCLUDES ) */

#if !defined( SIXTRL_NO_INCLUDES )
    #include "sixtracklib/common/definitions.h"
    #include "sixtracklib/common/internal/type_store_traits.hpp"
#endif /* !defined( SIXTRL_NO_INCLUDES ) */

#if defined( __cplusplus )

#if !defined( SIXTRL_NO_SYSTEM_INCLUDES )
    #include <type_traits>
#endif /* !defined( SIXTRL_NO_SYSTEM_INCLUDES ) */

namespace SIXTRL_CXX_NAMESPACE
{
    template< typename I, typename T = SIXTRL_REAL_TYPE >
    SIXTRL_STATIC SIXTRL_INLINE SIXTRL_FN typename std::enable_if<
        std::is_integral< I >::value, T >::type
    Math_factorial(
        typename TypeMethodParamTraits< I >::const_argument_type n )
    {
        /* generated by the following python code:

         from scipy.special import factorial
         import decimal
         from decimal import Decimal
         for ii in range( 0, 21 ):
             print( f"case I{{ {ii:2d} }}: {{ result = static_cast< T >( " +
                    f"{Decimal(factorial(ii,exact=True)):20.1f} );" +
                    f"  break; }}" )
         */

        T result = T{ 1 };

        switch( n )
        {
            case I{  0 }: { result = static_cast< T >(                    1.0 );  break; }
            case I{  1 }: { result = static_cast< T >(                    1.0 );  break; }
            case I{  2 }: { result = static_cast< T >(                    2.0 );  break; }
            case I{  3 }: { result = static_cast< T >(                    6.0 );  break; }
            case I{  4 }: { result = static_cast< T >(                   24.0 );  break; }
            case I{  5 }: { result = static_cast< T >(                  120.0 );  break; }
            case I{  6 }: { result = static_cast< T >(                  720.0 );  break; }
            case I{  7 }: { result = static_cast< T >(                 5040.0 );  break; }
            case I{  8 }: { result = static_cast< T >(                40320.0 );  break; }
            case I{  9 }: { result = static_cast< T >(               362880.0 );  break; }
            case I{ 10 }: { result = static_cast< T >(              3628800.0 );  break; }
            case I{ 11 }: { result = static_cast< T >(             39916800.0 );  break; }
            case I{ 12 }: { result = static_cast< T >(            479001600.0 );  break; }
            case I{ 13 }: { result = static_cast< T >(           6227020800.0 );  break; }
            case I{ 14 }: { result = static_cast< T >(          87178291200.0 );  break; }
            case I{ 15 }: { result = static_cast< T >(        1307674368000.0 );  break; }
            case I{ 16 }: { result = static_cast< T >(       20922789888000.0 );  break; }
            case I{ 17 }: { result = static_cast< T >(      355687428096000.0 );  break; }
            case I{ 18 }: { result = static_cast< T >(     6402373705728000.0 );  break; }
            case I{ 19 }: { result = static_cast< T >(   121645100408832000.0 );  break; }
            case I{ 20 }: { result = static_cast< T >(  2432902008176640000.0 );  break; }

            default:
            {
                I const nd = n / I{ 20 };
                I const remainder = n % I{ 20 };

                result = static_cast< T >( nd ) *
                         static_cast< T >( 2432902008176640000 );

                if( remainder != I{ 0 } )
                {
                    result += SIXTRL_CXX_NAMESPACE::Math_factorial<
                        I, T >( remainder );
                }
            }
        };

        return result;
    }

    template< typename I, typename T = SIXTRL_REAL_TYPE >
    SIXTRL_STATIC SIXTRL_INLINE SIXTRL_FN typename std::enable_if<
        std::is_integral< I >::value, T >::type
    Math_inv_factorial( typename TypeMethodParamTraits<
        I >::const_argument_type n )
    {
        T result = T{ 1.0 };

        /* generated by the following python code:

         from scipy.special import factorial
         import decimal
         from decimal import Decimal
         for ii in range( 0, 21 ):
               print( f"case I{{ {ii:2d} }}: {{ result = T{{ " +
                      f"{Decimal(1)/Decimal(factorial(ii,exact=True)):28.27g} }};" +
                      f"break; }}" )

         */

        switch( n )
        {
            case I{  0 }: { result = static_cast< T >( 1.  ); break; }
            case I{  1 }: { result = static_cast< T >( 1.  ); break; }
            case I{  2 }: { result = static_cast< T >( 0.5 ); break; }
            case I{  3 }: { result = static_cast< T >( 0.1666666666666666666666666667      ); break; }
            case I{  4 }: { result = static_cast< T >( 0.04166666666666666666666666667     ); break; }
            case I{  5 }: { result = static_cast< T >( 0.008333333333333333333333333333    ); break; }
            case I{  6 }: { result = static_cast< T >( 0.001388888888888888888888888889    ); break; }
            case I{  7 }: { result = static_cast< T >( 0.0001984126984126984126984126984   ); break; }
            case I{  8 }: { result = static_cast< T >( 0.00002480158730158730158730158730  ); break; }
            case I{  9 }: { result = static_cast< T >( 0.000002755731922398589065255731922 ); break; }
            case I{ 10 }: { result = static_cast< T >( 2.755731922398589065255731922E-7    ); break; }
            case I{ 11 }: { result = static_cast< T >( 2.505210838544171877505210839E-8    ); break; }
            case I{ 12 }: { result = static_cast< T >( 2.087675698786809897921009032E-9    ); break; }
            case I{ 13 }: { result = static_cast< T >( 1.605904383682161459939237717E-10   ); break; }
            case I{ 14 }: { result = static_cast< T >( 1.147074559772972471385169798E-11   ); break; }
            case I{ 15 }: { result = static_cast< T >( 7.647163731819816475901131986E-13   ); break; }
            case I{ 16 }: { result = static_cast< T >( 4.779477332387385297438207491E-14   ); break; }
            case I{ 17 }: { result = static_cast< T >( 2.811457254345520763198945583E-15   ); break; }
            case I{ 18 }: { result = static_cast< T >( 1.561920696858622646221636435E-16   ); break; }
            case I{ 19 }: { result = static_cast< T >( 8.220635246624329716955981237E-18   ); break; }
            case I{ 20 }: { result = static_cast< T >( 4.110317623312164858477990618E-19   ); break; }

            default:
            {
                result = T{ 1 } /
                    SIXTRL_CXX_NAMESPACE::Math_factorial< I, T >( n );
            }
        };

        return result;
    }
}

template< typename I, typename T = SIXTRL_REAL_TYPE >
SIXTRL_STATIC SIXTRL_INLINE SIXTRL_FN typename std::enable_if<
    std::is_integral< I >::value, T >::type
NS(Math_factorial)( typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    I >::const_argument_type n )
{
    return SIXTRL_CXX_NAMESPACE::Math_factorial< I, T >( n );
}

template< typename I, typename T = SIXTRL_REAL_TYPE >
SIXTRL_STATIC SIXTRL_INLINE SIXTRL_FN typename std::enable_if<
    std::is_integral< I >::value, T >::type
NS(Math_inv_factorial)( typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    I >::const_argument_type n )
{
    return SIXTRL_CXX_NAMESPACE::Math_inv_factorial< I, T >( n );
}

#endif /* C++ */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

SIXTRL_STATIC SIXTRL_FN SIXTRL_REAL_TYPE NS(Math_factorial)(
    SIXTRL_UINT64_TYPE const n ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN SIXTRL_REAL_TYPE NS(Math_inv_factorial)(
    SIXTRL_UINT64_TYPE const n ) SIXTRL_NOEXCEPT;

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

SIXTRL_INLINE SIXTRL_REAL_TYPE NS(Math_factorial)(
    SIXTRL_UINT64_TYPE const n ) SIXTRL_NOEXCEPT
{
    typedef SIXTRL_REAL_TYPE   real_t;
    typedef SIXTRL_UINT64_TYPE uint_t;

    real_t result = ( real_t )1;

    switch( n )
    {
        case ( uint_t )0:  { result = ( real_t )                         1.0; break; }
        case ( uint_t )1:  { result = ( real_t )                         1.0; break; }
        case ( uint_t )2:  { result = ( real_t )                         2.0; break; }
        case ( uint_t )3:  { result = ( real_t )                         6.0; break; }
        case ( uint_t )4:  { result = ( real_t )                        24.0; break; }
        case ( uint_t )5:  { result = ( real_t )                       120.0; break; }
        case ( uint_t )6:  { result = ( real_t )                       720.0; break; }
        case ( uint_t )7:  { result = ( real_t )                      5040.0; break; }
        case ( uint_t )8:  { result = ( real_t )                     40320.0; break; }
        case ( uint_t )9:  { result = ( real_t )                    362880.0; break; }
        case ( uint_t )10: { result = ( real_t )                   3628800.0; break; }
        case ( uint_t )11: { result = ( real_t )                  39916800.0; break; }
        case ( uint_t )12: { result = ( real_t )                 479001600.0; break; }
        case ( uint_t )13: { result = ( real_t )                6227020800.0; break; }
        case ( uint_t )14: { result = ( real_t )               87178291200.0; break; }
        case ( uint_t )15: { result = ( real_t )             1307674368000.0; break; }
        case ( uint_t )16: { result = ( real_t )            20922789888000.0; break; }
        case ( uint_t )17: { result = ( real_t )           355687428096000.0; break; }
        case ( uint_t )18: { result = ( real_t )          6402373705728000.0; break; }
        case ( uint_t )19: { result = ( real_t )        121645100408832000.0; break; }
        case ( uint_t )20: { result = ( real_t )       2432902008176640000.0; break; }

        default:
        {
            uint_t const nd = n / ( uint_t )20;
            uint_t const remainder = n % ( uint_t )20;

            result = ( ( real_t )nd ) * ( real_t )2432902008176640000;

            if( remainder != ( uint_t )0 )
            {
                result += NS(Math_factorial)( remainder );
            }
        }
    };

    return result;
}

SIXTRL_INLINE SIXTRL_REAL_TYPE NS(Math_inv_factorial)(
    SIXTRL_UINT64_TYPE const n ) SIXTRL_NOEXCEPT
{
    typedef SIXTRL_REAL_TYPE   real_t;
    typedef SIXTRL_UINT64_TYPE uint_t;

    /* Generated by python code:
       from scipy.special import factorial
       import decimal
       from decimal import Decimal
       for ii in range( 0, 21 ):
           print( f"case ( uint_t ){ii}: {{ result = ( real_t )" +
                  f"{Decimal(1)/Decimal(factorial(ii,exact=True)):g}; " +
                  f"break; }}" )
    */
    real_t result = ( real_t )1.0;

    switch( n )
    {
        case ( uint_t )0: { result = ( real_t )1; break; }
        case ( uint_t )1: { result = ( real_t )1; break; }
        case ( uint_t )2: { result = ( real_t )0.5; break; }
        case ( uint_t )3: { result = ( real_t )0.1666666666666666666666666667; break; }
        case ( uint_t )4: { result = ( real_t )0.04166666666666666666666666667; break; }
        case ( uint_t )5: { result = ( real_t )0.008333333333333333333333333333; break; }
        case ( uint_t )6: { result = ( real_t )0.001388888888888888888888888889; break; }
        case ( uint_t )7: { result = ( real_t )0.0001984126984126984126984126984; break; }
        case ( uint_t )8: { result = ( real_t )0.00002480158730158730158730158730; break; }
        case ( uint_t )9: { result = ( real_t )0.000002755731922398589065255731922; break; }
        case ( uint_t )10: { result = ( real_t )2.755731922398589065255731922e-7; break; }
        case ( uint_t )11: { result = ( real_t )2.505210838544171877505210839e-8; break; }
        case ( uint_t )12: { result = ( real_t )2.087675698786809897921009032e-9; break; }
        case ( uint_t )13: { result = ( real_t )1.605904383682161459939237717e-10; break; }
        case ( uint_t )14: { result = ( real_t )1.147074559772972471385169798e-11; break; }
        case ( uint_t )15: { result = ( real_t )7.647163731819816475901131986e-13; break; }
        case ( uint_t )16: { result = ( real_t )4.779477332387385297438207491e-14; break; }
        case ( uint_t )17: { result = ( real_t )2.811457254345520763198945583e-15; break; }
        case ( uint_t )18: { result = ( real_t )1.561920696858622646221636435e-16; break; }
        case ( uint_t )19: { result = ( real_t )8.220635246624329716955981237e-18; break; }
        case ( uint_t )20: { result = ( real_t )4.110317623312164858477990618e-19; break; }


        default:
        {
            result = ( real_t )1.0 / NS(Math_factorial)( n );
        }
    };

    return result;
}

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */
#endif /* SIXTRACKLIB_COMMON_INTERNAL_MATH_FACTORIAL_H__ */
